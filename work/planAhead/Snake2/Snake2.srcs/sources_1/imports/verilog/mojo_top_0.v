/*
   This file was generated automatically by the Mojo IDE version B1.3.6.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

module mojo_top_0 (
    input clk,
    input rst_n,
    output reg [7:0] led,
    input cclk,
    output reg spi_miso,
    input spi_ss,
    input spi_mosi,
    input spi_sck,
    output reg [3:0] spi_channel,
    input avr_tx,
    output reg avr_rx,
    input avr_rx_busy,
    input [5:0] b,
    output reg [3:0] power_led,
    output reg [1:0] gnd_led
  );
  
  
  
  localparam NUMBER_ROWS = 2'h2;
  
  localparam NUMBER_COLUMNS = 3'h4;
  
  localparam NUMBER_LEDS = 4'h8;
  
  localparam COORDINATE_BITS = 2'h3;
  
  localparam MINUS_ONE_OVERFLOW = 3'h7;
  
  reg rst;
  
  wire [1-1:0] M_reset_cond_out;
  reg [1-1:0] M_reset_cond_in;
  reset_conditioner_1 reset_cond (
    .clk(clk),
    .in(M_reset_cond_in),
    .out(M_reset_cond_out)
  );
  reg [7:0] M_led_state_d, M_led_state_q = 1'h0;
  reg [7:0] M_snake_pos_d, M_snake_pos_q = 1'h0;
  reg [7:0] M_food_pos_d, M_food_pos_q = 1'h0;
  wire [1-1:0] M_gameclk_value;
  counter_2 gameclk (
    .clk(clk),
    .rst(rst),
    .value(M_gameclk_value)
  );
  wire [1-1:0] M_muxclk_value;
  counter_3 muxclk (
    .clk(clk),
    .rst(rst),
    .value(M_muxclk_value)
  );
  wire [1-1:0] M_rnd_clk_value;
  counter_4 rnd_clk (
    .clk(clk),
    .rst(rst),
    .value(M_rnd_clk_value)
  );
  localparam XADD_direction_state = 3'd0;
  localparam XSUB_direction_state = 3'd1;
  localparam YADD_direction_state = 3'd2;
  localparam YSUB_direction_state = 3'd3;
  localparam ZADD_direction_state = 3'd4;
  localparam ZSUB_direction_state = 3'd5;
  
  reg [2:0] M_direction_state_d, M_direction_state_q = XADD_direction_state;
  localparam INITIALIZE_menu_state = 1'd0;
  localparam PLAY_menu_state = 1'd1;
  
  reg M_menu_state_d, M_menu_state_q = INITIALIZE_menu_state;
  wire [(4'h8+0)*8-1:0] M_food_next_pos_value;
  
  genvar GEN_food_next_pos0;
  generate
  for (GEN_food_next_pos0=0;GEN_food_next_pos0<4'h8;GEN_food_next_pos0=GEN_food_next_pos0+1) begin: food_next_pos_gen_0
    counter_5 food_next_pos (
      .clk(clk),
      .rst(rst),
      .value(M_food_next_pos_value[GEN_food_next_pos0*(4'h8)+(4'h8)-1-:(4'h8)])
    );
  end
  endgenerate
  
  reg [2:0] M_x_d, M_x_q = 1'h0;
  reg [2:0] M_y_d, M_y_q = 1'h0;
  reg [2:0] M_z_d, M_z_q = 1'h0;
  reg [9:0] M_score_d, M_score_q = 1'h0;
  
  wire [3-1:0] M_rnd_value;
  counter_6 rnd (
    .clk(M_rnd_clk_value),
    .rst(rst),
    .value(M_rnd_value)
  );
  
  wire [4-1:0] M_dis_led_cols;
  wire [2-1:0] M_dis_led_rows;
  display_7 dis (
    .clk(M_muxclk_value),
    .rst(rst),
    .led_state(M_led_state_q),
    .led_cols(M_dis_led_cols),
    .led_rows(M_dis_led_rows)
  );
  
  always @* begin
    M_direction_state_d = M_direction_state_q;
    M_menu_state_d = M_menu_state_q;
    M_food_pos_d = M_food_pos_q;
    M_snake_pos_d = M_snake_pos_q;
    M_score_d = M_score_q;
    M_led_state_d = M_led_state_q;
    M_z_d = M_z_q;
    M_y_d = M_y_q;
    M_x_d = M_x_q;
    
    M_reset_cond_in = ~rst_n;
    rst = M_reset_cond_out;
    led = 8'h00;
    spi_miso = 1'bz;
    spi_channel = 4'bzzzz;
    avr_rx = 1'bz;
    M_snake_pos_d = 8'h01 << (M_x_q + (2'h2 * M_y_q) + (3'h4 * M_z_q));
    M_led_state_d = M_snake_pos_q | M_food_pos_q;
    
    case (M_menu_state_q)
      INITIALIZE_menu_state: begin
        M_food_pos_d = 8'h02;
        M_menu_state_d = PLAY_menu_state;
      end
      PLAY_menu_state: begin
        
        case (M_direction_state_q)
          XADD_direction_state: begin
            if (M_x_q + 1'h1 == 2'h2) begin
              M_x_d = 1'h0;
            end else begin
              M_x_d = M_x_q + 1'h1;
            end
          end
          XSUB_direction_state: begin
            if (M_x_q - 1'h1 == 3'h7) begin
              M_x_d = 3'h1;
            end else begin
              M_x_d = M_x_q - 1'h1;
            end
          end
          YADD_direction_state: begin
            if (M_y_q + 1'h1 == 2'h2) begin
              M_y_d = 1'h0;
            end else begin
              M_y_d = M_y_q + 1'h1;
            end
          end
          YSUB_direction_state: begin
            if (M_y_q - 1'h1 == 3'h7) begin
              M_y_d = 3'h1;
            end else begin
              M_y_d = M_y_q - 1'h1;
            end
          end
          ZADD_direction_state: begin
            if (M_z_q + 1'h1 == 2'h2) begin
              M_z_d = 1'h0;
            end else begin
              M_z_d = M_z_q + 1'h1;
            end
          end
          ZSUB_direction_state: begin
            if (M_z_q - 1'h1 == 3'h7) begin
              M_z_d = 3'h1;
            end else begin
              M_z_d = M_z_q - 1'h1;
            end
          end
        endcase
      end
    endcase
    if (b[0+0-:1]) begin
      M_direction_state_d = XADD_direction_state;
    end
    if (b[1+0-:1]) begin
      M_direction_state_d = XSUB_direction_state;
    end
    if (b[2+0-:1]) begin
      M_direction_state_d = YADD_direction_state;
    end
    if (b[3+0-:1]) begin
      M_direction_state_d = YSUB_direction_state;
    end
    if (b[4+0-:1]) begin
      M_direction_state_d = ZADD_direction_state;
    end
    if (b[5+0-:1]) begin
      M_direction_state_d = ZSUB_direction_state;
    end
    power_led = M_dis_led_cols;
    gnd_led = M_dis_led_rows;
    if (M_snake_pos_q == M_food_pos_q) begin
      M_score_d = M_score_q + 1'h1;
      M_food_pos_d = 8'h01 << M_rnd_value;
    end
  end
  
  always @(posedge M_gameclk_value) begin
    M_x_q <= M_x_d;
    M_y_q <= M_y_d;
    M_z_q <= M_z_d;
    M_score_q <= M_score_d;
  end
  
  
  always @(posedge clk) begin
    M_led_state_q <= M_led_state_d;
    M_snake_pos_q <= M_snake_pos_d;
    M_food_pos_q <= M_food_pos_d;
    
    if (rst == 1'b1) begin
      M_direction_state_q <= 1'h0;
      M_menu_state_q <= 1'h0;
    end else begin
      M_direction_state_q <= M_direction_state_d;
      M_menu_state_q <= M_menu_state_d;
    end
  end
  
endmodule
